<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
        <title>Offline Karel (one file Karel)</title>
        <style>
            textarea {
                padding-left: .2em;
                white-space: pre;
                overflow-wrap: normal;
                overflow-x: scroll;

                width: 100%;
                height: 100%;
                display: block;
            }
            #everything_holder {
                overflow: hidden;
                max-width: 1200px;
                margin: auto;
            }
            #canvas_holder {
                overflow: hidden;
            }
            canvas {
                float:right;
                width:99%;
                /* height:100%; */
                border:2px solid #000000;

                image-rendering: optimizeSpeed;
                image-rendering: crisp-edges;
                image-rendering: -moz-crisp-edges;
                image-rendering: -o-crisp-edges;
                image-rendering: -webkit-optimize-contrast;
                -ms-interpolation-mode: nearest-neighbor;
            }
            #popup_div {
                display:none;
                overflow:hidden;
                position:absolute;
                left:0;
                top:0;
                width:100%;
                height:100%;
                background-color:#357;
                opacity:0.4;
            }
            #message_div {
                display:none;
                position:absolute;
                left:calc(50% - 10em);
                width: 20em;
                top:calc(50% - 5em);
                height: 10em;
                padding:1em;
                background-color:#444;
                border:.1em solid #111;
                color:#EFE;
                text-align: center;
            }

        </style>
        
        <script>
            const tab_size = 2
            let error_popup_on = true

            const constants = {
                tab_size: tab_size,
                tab_space_string: Array(tab_size + 1).join(" "),
                max_rows: 100,
                max_cols: 100,
                // directions
                right: 0,
                down: 1,
                left: 2,
                up: 3,
                functions: {
                    'move': true,
                    'turn_left': true,
                    'put_beeper': true,
                    'pick_beeper': true
                },
                conditions: {
                    'front_is_clear': true,
                    'front_is_blocked': true,
                    'beepers_present': true,
                    'no_beepers_present': true,
                    'left_is_clear': true,
                    'left_is_blocked': true,
                    'right_is_clear': true,
                    'right_is_blocked': true,
//beepers_in_bag()	no_beepers_in_bag()	Does Karel have any beepers in its bag?
                    'facing_north': true,
                    'not_facing_north': true,
                    'facing_south': true,
                    'not_facing_south': true,
                    'facing_east': true,
                    'not_facing_east': true,
                    'facing_west': true,
                    'not_facing_west': true
                },
                playground_buttons: [
                    "move_button",
                    "turn_button",
                    "put_button",
                    "pick_button",
                    "reset_button"
                ],
                code_buttons: [
                    "rewind_button",
                    "play_back_button",
                    "back_button",
                    "pause_button",
                    "forward_button",
                    "play_button",
                    "fast_forward_button"
                ]
            }

            // images and styles
            const base64s = {
                chubbs: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBMh5S5kY0AAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAeVJREFUWMOtl62SgzAQx/+56UyRPMa5q0T2MZCRlZWVlX2EypV5hJOVkch7DOS6PVGgIZOQBNiZnWEIyf6yXwkK5SKR92rFWkWTBADYe1ltBPnKNc4R47Y3EBGICGxvljy0WoQGZUcBiO2N+GJ7IyUQKhNgEu0OSNiOUmp1TkQ9MOxK5G11tvvQ2J6hEADCr48CEOYuCsDcZQMcMsMk+M0nPh5/9k3CkNrezLywNhkPObVPgYGmbmF7g1Nkx6fq211DrQEQAtAGBozz3PFfFGKE1wmIaObzgpITijEcY/Ixd1MIeF5F64xTAsIFGdVfJxciaJwSHqFAkpLTMd3umeqEwoE4u9IWlpAZuid9uqhaBAi1XdoA4J2YKucsEC+DN0OYyO5jx7FyDVLgEDI7djmVaj5t4NJR4g3jwef0g1nm00Km+xm/9F2sDL9yY9gON6JQW9aDl6rh+fm6grkDc4dYKy+9kk1xH0F4AQgAyBLIUjJMKucWVNIL/Jh7Sax2ASiBwVqAUMavFb1gK3Qcy7V5oNbNe/LlvAlCJ0oveSW7P1/QlzNKPaIz6z4aAtcLE4wDkgM+fK+2XkoBADdd435JQ4/Sk938YzLzwk3XqKpTck7pj0/SA+NOHmj2/tnNmiBbDaTkH10zqfNKfmQ4AAAAAElFTkSuQmCC',
                big_boo_scaled2x: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mlYpUHOwg0iFDdbKLijiWWiyChdJWaNXB5NI/aNKQpLg4Cq4FB38Wqw4uzro6uAqC4A+Is4OToouU+F1SaBHjwd09vPe9L3ffAUK7zlQzEAdUzTKyqYRYKK6KwVcEEEGQ1pDETD2dW8zDc3zdw8f3uxjP8q77cwwrJZMBPpE4znTDIt4gntu0dM77xGFWlRTic+Ipgy5I/Mh12eU3zhWHBZ4ZNvLZBeIwsVjpY7mPWdVQiWeJo4qqUb5QcFnhvMVZrTdZ9578haGStpLjOs0IUlhCGhmIkNFEDXVYiNGukWIiS+cJD/+448+QSyZXDYwcSTSgQnL84H/wu7dmeWbaTQolgIEX2/6YAIK7QKdl29/Htt05AfzPwJXW8zfawPwn6a2eFj0CRraBi+ueJu8BlzvA2JMuGZIj+WkK5TLwfkbfVARGb4GhNbdv3XOcPgB56tXyDXBwCExWKHvd492D/X37t6bbvx9Hg3KVgZhZowAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+gEHAc3CqwRIgcAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAACrklEQVR42u3asU7DMBAG4D8IKR15DDYYGRl5hLJ17AYjYx+BsSMbfQRGRkbYeAzGdjIDsdSYOD7bZyeg/6RKJa2iRPn6ny8BYLH+a5nuNWmd8DqMVzMTKRrHbEqcEwXNSNCgFGP6m5umifq89LlRUKBOa4lxJSTvNF0UBf0VQUZTjDSb3O1N06h0NQrKEBR7BQwA7PfvKhnjE+PLHFfUiCQT0+0oKEGQifwtq8iRSnIzKZR17nkMdMHR86OgCEFG+Fvulbac2K4l/V6sPApKzaDD4QMA0LYXohXsYnFZVFKpTDuSxy6mNc0PdiNXUm4GSLOgdAZJ13cUFCtos30FADyszqIkpXYp7ZktQSgzSEvQoKSz1RUAYI3PKEm+bpiaWdqSKKjCNA8A+Hp6+3nTZZJPxlyzKLcoKCGDRFkkLV8Ghab13IySygxlEQXlZpBbW5yLJEkzKvSUIvWphVamUVCGoAYANuvrnyxCP4u06zZSik+edjekoIwuNtjVHvf73kZfFvkyyF7pZff3c3fFfYJ2AUG5K3N2sdpdrHb2LMNXvuhKnIIUMmgwe9xys0iaQbm1SxRkZ0p7T50ZVDqD7FSvtQ66CXz+MrEcClIQ1JvmpTOarTtlYS+Z+7Ny2MUqCIqSU6tuPJKkMlzhFFRAkEiOVjdbBrpTqHul/i/A/WIRNYdS0NxnsZCsXeJ+UjOHghRmsagu5suiu7YdncXsZNd2K+FDYKq3klaeDAqJic0eClKY5kWSUgW5M9RBeE/aOgjdXaCgGQiqKikkqHXuQUsFpcqhIEVBKt1N2tV8ctzvu2VF2ZX+Zn2dJYeCCggquk5KfQZfSg4FFRTUk2Rr6vtH2nIoqIKgSUUdiSkih4ImEDQq6pcAobABKTWOnYLmIChL2EyOkYJYLBZrzvUNlL1GOa6bdTUAAAAASUVORK5CYII=',
                tiny_circle: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVBbDsQgCPz3FHsEeUjhOLZ1k73BHn9RadM2O4kjDGREUvt+3unVgcCJy6JiItnBxobVA80TdTBkHnzVen7T01lAl8hvmqlK9B86nAbzqh6Vi5FuUVjvBePw14dRPER9IvRgDyMLI8JZgDCoMamYLtcvrC3fofOkTrLl8REI92fOi29vL/4OITYCys5EMgegfjhR9YCdkdQbgYrHhWwoEpP4Qv7t6UD6Aco/Wkl94KE3AAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AYht+mlYpUHOwg0iFDdbKLijiWWiyChdJWaNXB5NI/aNKQpLg4Cq4FB38Wqw4uzro6uAqC4A+Is4OToouU+F1SaBHjwd09vPe9L3ffAUK7zlQzEAdUzTKyqYRYKK6KwVcEEEGQ1pDETD2dW8zDc3zdw8f3uxjP8q77cwwrJZMBPpE4znTDIt4gntu0dM77xGFWlRTic+Ipgy5I/Mh12eU3zhWHBZ4ZNvLZBeIwsVjpY7mPWdVQiWeJo4qqUb5QcFnhvMVZrTdZ9578haGStpLjOs0IUlhCGhmIkNFEDXVYiNGukWIiS+cJD/+448+QSyZXDYwcSTSgQnL84H/wu7dmeWbaTQolgIEX2/6YAIK7QKdl29/Htt05AfzPwJXW8zfawPwn6a2eFj0CRraBi+ueJu8BlzvA2JMuGZIj+WkK5TLwfkbfVARGb4GhNbdv3XOcPgB56tXyDXBwCExWKHvd492D/X37t6bbvx9Hg3KVP2+z7gAADXZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDQuNC4wLUV4aXYyIj4KIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgIHhtbG5zOkdJTVA9Imh0dHA6Ly93d3cuZ2ltcC5vcmcveG1wLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICB4bXBNTTpEb2N1bWVudElEPSJnaW1wOmRvY2lkOmdpbXA6OGIzNTNlNjQtNmU4Yi00MTg0LWI0ZGItZTU2MDEyOTc4NjRlIgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjlmYzk0ZDQ3LWU0ZDAtNDkyYS04ODBkLTkxYzI2ZTc5YzgzMiIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjg4MzNiM2MwLWFhZGMtNDI0NC1iYWYyLTZlNDUyZmZhY2UyZiIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIEdJTVA6QVBJPSIyLjAiCiAgIEdJTVA6UGxhdGZvcm09IldpbmRvd3MiCiAgIEdJTVA6VGltZVN0YW1wPSIxNzE0MjkxMTY2MjA0NDc5IgogICBHSU1QOlZlcnNpb249IjIuMTAuMzYiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIgogICB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0OjA0OjI4VDE1OjU5OjI2KzA4OjAwIgogICB4bXA6TW9kaWZ5RGF0ZT0iMjAyNDowNDoyOFQxNTo1OToyNiswODowMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjJhYWZlYTI0LTc4MWEtNGIxMy1iNzRmLTUyYzNjM2E4NzZiZCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNC0wNC0yOFQxNTo1OToyNiIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4CNERCAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH6AQcBzsaHRN9bwAAAGlJREFUGNONULkRgDAMM0zBCB4hI1BmlIzhcTIGZcqMok40EPJxF3WWdZItkUVs3cy/fS1k9q5RabwGM2bvCAt8XAkLzN6xT6lFU24v9HmMH1TcJ1QVJJMSnUxEddoAgcgXQGxOWa5nGTfJujesuLP+fAAAAABJRU5ErkJggg==',
            }
            const ball_brown = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxEAAAsRAX9kX5EAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQffCBQUMwu4IThHAAABh2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iPjxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+PHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQo8P3hwYWNrZXQgZW5kPSd3Jz8+LJSYCwAAAKpJREFUOE+llMENwyAMRV9YoN0sa3SBnDpCr52gG3SzcMmVHsDUWIYG9UmIxOR//RCTBZ9kC4rlVyEBPG/5Jh5mFbi/6mXVapMkYo012mOeH28QfShrroHH9ZLnbQVJLiZ/EWZSWCTNMIndjx6BzsNeDbWxmpokHu2YYfg6Fi8FMyY9A1SzpW399oAwEqIarkmyx3acpWn78t1PodvePYAjsyKmdwA1U7+CD1suOy0YHL1EAAAAAElFTkSuQmCC'
            const big_font = {
                base64_border_skinny: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSkUqDlYQ6ZChOtlFRQQXqWIRLJS2QqsOJpd+QZOGJMXFUXAtOPixWHVwcdbVwVUQBD9AnB2cFF2kxP8lhRYxHhz34929x907QGhWmWoG5gBVs4x0Ii7m8qti8BUBRCBgFkMSM/VkZjELz/F1Dx9f72I8y/vcn6NfKZgM8InEc0w3LOIN4ulNS+e8TxxmZUkhPiceN+iCxI9cl11+41xyWOCZYSObnicOE4ulLpa7mJUNlXiKOKqoGuULOZcVzluc1Wqdte/JXxgqaCsZrtOMIIElJJGCCBl1VFCFhRitGikm0rQf9/CPOP4UuWRyVcDIsYAaVEiOH/wPfndrFicn3KRQHOh5se2PUSC4C7Qatv19bNutE8D/DFxpHX+tCcx8kt7oaNEjYGAbuLjuaPIecLkDDD/pkiE5kp+mUCwC72f0TXlg8BboW3N7a+/j9AHIUlfLN8DBITBWoux1j3f3dvf275l2fz/arHLQqyhwQQAAAAlwSFlzAAAK8AAACvABQqw0mAAAAAd0SU1FB+gEHAMzD78eu1AAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAATUlEQVQoz+2SMQoAIAzEUnFw8P8vdXAQdCqKIFTFzRvL5bpEAPBUdlIQUSinbGJCDAAInqqQHlcZe25esnwDOribDz4FLeaMnQvlDiVvT0oZIUsApLgAAAAASUVORK5CYII=',
                base64_border: ball_brown,
                base64_numbers: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAMCAYAAADif6roAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxEAAAsRAX9kX5EAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQffCBQUMwu4IThHAAABh2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iPjxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+PHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQo8P3hwYWNrZXQgZW5kPSd3Jz8+LJSYCwAAAWpJREFUWEfFlFuSgzAMBEe5/529H2FAHsuSyJLdrkpVbDV6YMBwMdx/ADBZE3pVnKinceI9raFrv6d06j2RR+PInHOQMWbHzHycnF4VJ+ItcVwODk9rIKgZ5sG9er/KE8yfOt3Bju0rUVYoybNMFTmdPOoIbUc3O7U+cV7oY5uGT8xsNxSx4/dNOvnpTK4+kU/SOg3nq6tD7V4fOLdyxiFNDvEHqY70tNTB6pDobUXWT8eBq3fnia6YDkGe7mkwjUuD787WHEs+dY48y7Qdh2gNuP6CPBPaj+fJG71Dq+o6InOy2FPcrVH6f3Gj9eh1vcOSAcYYI3yq/omykelGF81P37HsFWQel4/eeYOKWm06eTpOhyxPNdcL83fpJNr7Fp/Uiq7RPV3v9iqia6I9xTv8tx7BG5+tcnZxYk1H0Wuqep2eUXjah8ZJ1Qvo3CmGhqNxktUhmsvDa9TRXBpH4KDwohiCPOppHN75Aa+LEzIlyvE1AAAAAElFTkSuQmCC',
                img_border: null,
                img_numbers: null,
                width: 9,
                height: 12,
                bg: "#FFF"
            }
            const small_font = {
                base64_border_skinny: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSkUqDlYQ6ZChOtlFRQQXqWIRLJS2QqsOJpd+QZOGJMXFUXAtOPixWHVwcdbVwVUQBD9AnB2cFF2kxP8lhRYxHhz34929x907QGhWmWoG5gBVs4x0Ii7m8qti8BUBRCBgFkMSM/VkZjELz/F1Dx9f72I8y/vcn6NfKZgM8InEc0w3LOIN4ulNS+e8TxxmZUkhPiceN+iCxI9cl11+41xyWOCZYSObnicOE4ulLpa7mJUNlXiKOKqoGuULOZcVzluc1Wqdte/JXxgqaCsZrtOMIIElJJGCCBl1VFCFhRitGikm0rQf9/CPOP4UuWRyVcDIsYAaVEiOH/wPfndrFicn3KRQHOh5se2PUSC4C7Qatv19bNutE8D/DFxpHX+tCcx8kt7oaNEjYGAbuLjuaPIecLkDDD/pkiE5kp+mUCwC72f0TXlg8BboW3N7a+/j9AHIUlfLN8DBITBWoux1j3f3dvf275l2fz/arHLQqyhwQQAAAAlwSFlzAAAK8AAACvABQqw0mAAAAAd0SU1FB+gEHAMzD78eu1AAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAATUlEQVQoz+2SMQoAIAzEUnFw8P8vdXAQdCqKIFTFzRvL5bpEAPBUdlIQUSinbGJCDAAInqqQHlcZe25esnwDOribDz4FLeaMnQvlDiVvT0oZIUsApLgAAAAASUVORK5CYII=',
                base64_border: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAOCAYAAAA1+Nx+AAAA7HpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjajVHbDcMgDPxnio7gV3iMQ15SN+j4PYJJmkqVagnjOxtjjrC9nnt4NJMswaaUY4mRYFasSEWQqdt8eCY7fAcjx3c+0OYJAaXYtcMizm/gEbPj4o141J+Nxk0V0XQlanV+vvOzN5T83cgTyv1mWv2AN1LxiazjxSeKJafb09aF7pavZZokTpGTwZtQSrEgzkKWoOfaBt2FDn0Dl35+EAOPUsFMsikrwavGPqW2ZVqxNy+aAwpZJwAD2RJdeMJXYoSr8V7pFPNTm0ujH/bPs8Ib7aR2HyZYHRkAAAGEaUNDUElDQyBwcm9maWxlAAB4nH2RPUjDQBiG36aVilQc7CDSIUN1souKOJZaLIKF0lZo1cHk0j9o0pCkuDgKrgUHfxarDi7Oujq4CoLgD4izg5Oii5T4XVJoEePB3T28970vd98BQrvOVDMQB1TNMrKphFgororBVwQQQZDWkMRMPZ1bzMNzfN3Dx/e7GM/yrvtzDCslkwE+kTjOdMMi3iCe27R0zvvEYVaVFOJz4imDLkj8yHXZ5TfOFYcFnhk28tkF4jCxWOljuY9Z1VCJZ4mjiqpRvlBwWeG8xVmtN1n3nvyFoZK2kuM6zQhSWEIaGYiQ0UQNdViI0a6RYiJL5wkP/7jjz5BLJlcNjBxJNKBCcvzgf/C7t2Z5ZtpNCiWAgRfb/pgAgrtAp2Xb38e23TkB/M/AldbzN9rA/CfprZ4WPQJGtoGL654m7wGXO8DYky4ZkiP5aQrlMvB+Rt9UBEZvgaE1t2/dc5w+AHnq1fINcHAITFYoe93j3YP9ffu3ptu/H0eDcpU/b7PuAAANdmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDo4OTAxZjk0OC05YTIyLTRkNmUtODRmMS00MTEyNGFkYzIwMjgiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YzExYmJkNWItMWFlNy00ZTBiLThjZTMtNjUxODZjODljMDIzIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6MGQxMGY2NTQtMGUwOC00NmFjLWFhMWUtMTYzZDkzZmY5NTg5IgogICBkYzpGb3JtYXQ9ImltYWdlL3BuZyIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iV2luZG93cyIKICAgR0lNUDpUaW1lU3RhbXA9IjE3MTQyOTAwMDI5MDkxODYiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zNiIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQ6MDQ6MjhUMTU6NDA6MDArMDg6MDAiCiAgIHhtcDpNb2RpZnlEYXRlPSIyMDI0OjA0OjI4VDE1OjQwOjAwKzA4OjAwIj4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MTk2NzA2ZmUtNmZmYi00MmJlLThiY2QtNmQ4NzExNjdhZTcwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKFdpbmRvd3MpIgogICAgICBzdEV2dDp3aGVuPSIyMDI0LTA0LTI4VDE1OjQwOjAyIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pj7KAXkAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACvAAAArwAUKsNJgAAAAHdElNRQfoBBwHKAJvkKSrAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAFBJREFUOMvtlCEOACAMxDqCQPD/lyImSEAtECwbipMT7ZmdAJAZRKQjYnBt6soutQAgZIbB7XibnZdOo2d7YAmi8gVf4Cjw/OSd9WAqgsduAnhFGSF4byczAAAAAElFTkSuQmCC',
                base64_numbers: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAHCAYAAACMTYoWAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSkUqDlYQ6ZChOtlFRQQXqWIRLJS2QqsOJpd+QZOGJMXFUXAtOPixWHVwcdbVwVUQBD9AnB2cFF2kxP8lhRYxHhz34929x907QGhWmWoG5gBVs4x0Ii7m8qti8BUBRCBgFkMSM/VkZjELz/F1Dx9f72I8y/vcn6NfKZgM8InEc0w3LOIN4ulNS+e8TxxmZUkhPiceN+iCxI9cl11+41xyWOCZYSObnicOE4ulLpa7mJUNlXiKOKqoGuULOZcVzluc1Wqdte/JXxgqaCsZrtOMIIElJJGCCBl1VFCFhRitGikm0rQf9/CPOP4UuWRyVcDIsYAaVEiOH/wPfndrFicn3KRQHOh5se2PUSC4C7Qatv19bNutE8D/DFxpHX+tCcx8kt7oaNEjYGAbuLjuaPIecLkDDD/pkiE5kp+mUCwC72f0TXlg8BboW3N7a+/j9AHIUlfLN8DBITBWoux1j3f3dvf275l2fz/arHLQqyhwQQAAAAlwSFlzAAAK8AAACvABQqw0mAAAAAd0SU1FB+gEHAMxO6ycLWcAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA40lEQVRIx61WuxKEMAhE52aS4v7/Sy3o7hrjIENgV0OjBiE8lk221tpPTtFDxUr/dvEy/sl0iH2kt76jfbx/Jka/hvifxZft7WWPAvBBIIIEPEuSlREjC4Chj/at8i/16nI9vz9MYlnwyFrWcQa9eig0QQx62SaF66rSe7+eF4Irh0wDUATNEIigl52OCHWz5qN6/88oqC3ujSKYDlY2mV02ftl75ncFQBD6uhXU87MprKWLfQU9REXxaxnfRpz6hmPZAxpt0NTeFNeiV0RkG7cI9AStAq+SWHFDeaJ/ewN6OiV/DnsBZgQBR/EAAAAASUVORK5CYII=',
                img_border: null,
                img_numbers: null,
                width: 8,
                height: 7,
                bg: "#FFF"
            }
            const styles = {
                "flower": {
                    empty_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBLwfJ4YLoAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAIlJREFUOMulkz0OwCAIhdE4eLyOPaIjx9OJDkr8RWn7FhP0gxcBA2uREDenAAEAEGU+pf7a+5lrXxCDrbokWBLdlbU7eNKVjxiqWws/ZdXVB7GLrYPxEyUHy4dLGOeQe1NNdKAS/kmA8hX7phhqnzUgD5PTAqBYDiq9Paod5eUySYkKKC7Tp3V+AE8QMTCfSkf3AAAAAElFTkSuQmCC',
                    beeper_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBLxU6WPOgAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAXZJREFUWMOtV7EVAjEIhXspbixLR7B0jBvBMSwdwdLSkeywkTMhhBAu6e4S4BPgExBii8Q3BvWEBGmmPowaJ/rjQMSwzhCA3LgCAkdClRzXPDNMJPXhYHxJ874RCleY0kB8ye2+ApKIKoAAAEtPmIjA8tpj3FppRDF7oHkSXWm4bjPjn8///7qW+/ImGlWiJ6EhXBjVFgMxcqlLGgUIj3E2yvsSRCNkqCUhtUoqV54b0JYEyoksbpYkAIpmvgri1ecGAKDkiT0r83o8UlGLxe8tY71cgLcfzOI++a4TbGj/EA88AeBse7iestg/3VyC2OoBVQluPxCnMsn4ez/DgG6+hoRWIyoSUVEu/2v7DR5wPR4qMroDwGXTr/XxM3qFyUyo1fJdEbo6uqIGwgWgBSTSkiWIxWvcoNTwWyDcjntUzWfmEtHgQwQRq/OafPJ4EHgB7fxitWIzCXuKg7OBay7AmbNfT/bQ0DFjPIt6Nm1APfq+PhyqL2nU2YRUjg5lAAAAAElFTkSuQmCC',
                    karel_img: base64s.big_boo_scaled2x,
                    font: big_font,
                    empty: new Image(),
                    beeper: new Image(),
                    karel: new Image(),
                    imgw: 72,
                    imgh: 72,
                    bg: '#FDB'
                },
                "frog": {
                    empty_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAECAYAAABLLYUHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxAAAAsQAa0jvXUAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQffCBQUMwu4IThHAAABh2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iPjxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+PHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQo8P3hwYWNrZXQgZW5kPSd3Jz8+LJSYCwAAACFJREFUGFc1yTEOADAMg8BLP+6nJ0NlJhB8FqYCD5K06T1x/wR+TvdmxQAAAABJRU5ErkJggg==',
                    beeper_img: ball_brown,
                    karel_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBIwts4oHPAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAXxJREFUSMftVjuugzAQnI0ihWO8I7ik5Ag5wivpHmWOkNJ0HCFljpCSkiPkGFD5FcEr4x82pGQlBNLaO96d9SzAYYcd9iWjDXtUJIZKjZ8LrMT9CgCoy5/Pu5I6Tsy3C9gJrK2uJGI+Hw7tKPEuSk85u+U4QinFDwB+x3w+O+3pzFjgmG9LNys5jsq0mfugz3g2ccyNNdyeC0f3auxGcnxd/3b20Z5uzrWuf/Phz1tBhSijG4ehR11Jzlp/a3DKKbFZ1lRwO+O55BSSu4UScaDbE+J+zS65xTEB4FIrq0lU6Iq004S6KHaLCPmAfVL42zzwd7lkIbXTBABoPgclr4Bo0oUoV7lLtdhBzzYXtQHevRrUlYQcx6/PY50xmRfc7ka7dDml9pXZq9V8yWdwH/c5/KYMCc6669+O/PEiomjQdppA8y0NZetwHOrqoSp49HHAFd5joMH/Jc9AIO0PDYuFovnXpN1jU95M+fSplknLyhpygHMqElmrUtXrH5MJ+9Szi0ZhAAAAAElFTkSuQmCC',
                    font: big_font,
                    empty: new Image(),
                    beeper: new Image(),
                    karel: new Image(),
                    imgw: 34,
                    imgh: 34,
                    bg: '#DEF'
                },
                // "frog2": {
                //     empty_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBGjNKZLTrAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAADhJREFUSMft0bEJADAMA0GRiTxKxsrWcpMylVMYzB+oFkISAAAA8OCbklUtta04Wz/lLYv5mI/nSQ8KFAP/WXxQAAAAAElFTkSuQmCC',
                //     beeper_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBGxNoEaViAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAN9JREFUSMftlTEOgzAMRX+iSuQ4PUZHxo49To/B2JGRo4XJHRBtSKLUDlarovwFZMAvHzsO0HR0mYpvSCOXkQK9j6LjcnFXWU4umFZg1y2G59kkcAyAm3h5rQTq3DsY3r90A/ylWA4ReOM0cQsAvbxRLMdtEZoRx7WVrDJsrKTJhDpxXvroctT/1cVmSmKDMjjbwYxne/dxdjsBgH/k3XL2MqvGaw03oC/NaipChW7FszqBR83EhdacThQMiBgoymcqS0RKef5LxDmFVGZ1CCUinO899sB/4rjVuNX4eHoCbZFN/iINYbEAAAAASUVORK5CYII=',
                //     karel_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU/TiiIVEYuIOmSoTnZREcdSxSJYKG2FVh1MXvoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJES70sKLWK88Hgf591zeO8+QGhUmGoGooCqWUYqHhOzuVWx+xUBjMKHIQxIzNQT6cUMPOvrnjqp7iI8y7vvz+pT8iYDfCJxlOmGRbxBPLtp6Zz3iUOsJCnE58STBl2Q+JHrsstvnIsOCzwzZGRS88QhYrHYwXIHs5KhEs8QhxVVo3wh67LCeYuzWqmx1j35C4N5bSXNdVpjiGMJCSQhQkYNZVRgIUK7RoqJFJ3HPPwjjj9JLplcZTByLKAKFZLjB/+D37M1C9NTblIwBnS92PbHONC9CzTrtv19bNvNE8D/DFxpbX+1Acx9kl5va+EjoH8buLhua/IecLkDDD/pkiE5kp+WUCgA72f0TTlg8BboXXPn1jrH6QOQoVkt3wAHh8BEkbLXPd7d0zm3f3ta8/sBb1lypWgHKyMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoBBsBIwts4oHPAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAXxJREFUSMftVjuugzAQnI0ihWO8I7ik5Ag5wivpHmWOkNJ0HCFljpCSkiPkGFD5FcEr4x82pGQlBNLaO96d9SzAYYcd9iWjDXtUJIZKjZ8LrMT9CgCoy5/Pu5I6Tsy3C9gJrK2uJGI+Hw7tKPEuSk85u+U4QinFDwB+x3w+O+3pzFjgmG9LNys5jsq0mfugz3g2ccyNNdyeC0f3auxGcnxd/3b20Z5uzrWuf/Phz1tBhSijG4ehR11Jzlp/a3DKKbFZ1lRwO+O55BSSu4UScaDbE+J+zS65xTEB4FIrq0lU6Iq004S6KHaLCPmAfVL42zzwd7lkIbXTBABoPgclr4Bo0oUoV7lLtdhBzzYXtQHevRrUlYQcx6/PY50xmRfc7ka7dDml9pXZq9V8yWdwH/c5/KYMCc6669+O/PEiomjQdppA8y0NZetwHOrqoSp49HHAFd5joMH/Jc9AIO0PDYuFovnXpN1jU95M+fSplknLyhpygHMqElmrUtXrH5MJ+9Szi0ZhAAAAAElFTkSuQmCC',
                //     font: small_font,
                //     empty: new Image(),
                //     beeper: new Image(),
                //     karel: new Image(),
                //     imgw: 34,
                //     imgh: 34,
                //     bg: '#DEF'
                // },
                "monkey": {
                    empty_img: base64s.tiny_circle,
                    beeper_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMwCPz3FB2Blx08jvOo1A06fiGQKImK5AMO+wyU7ft5l5cboRSpk7beGphJl07DAoWwsSOC7BgJZQ3vfDkLZBSb50i1nQ+Dx1Mg3LCoXoR0ycJ8L3RJfX0I5UfsHXkTawr1FGKKAqbAiLGgdZ2uI8wb3E3jFIe2wD4Ipvozl8m2t1b7h4k2RgZD5hYNsB8pPCwQQ7JLTqHF1bzzx0i2kH97Oqz8AEBfWdj2gKqwAAABhWlDQ1BJQ0MgcHJvZmlsZQAAeJx9kTtIw0Acxr8+pCItDhYRdchQnezgA3EsVSyChdJWaNXB5NIXNGlIUlwcBdeCg4/FqoOLs64OroIg+ABxdnBSdJES/5cUWsR4cNyP7+77uPsO8DarTDH8MUBRTT2diAu5/KoQeIUfgwhhEiMiM7RkZjEL1/F1Dw9f76I8y/3cnyMkFwwGeATiGNN0k3iDeHbT1DjvE4dZWZSJz4kndLog8SPXJYffOJds9vLMsJ5NzxOHiYVSF0tdzMq6QjxDHJEVlfK9OYdlzluclWqdte/JXxgsqCsZrtMcRQJLSCIFARLqqKAKE1FaVVIMpGk/7uIftv0pcknkqoCRYwE1KBBtP/gf/O7WKE5POUnBONDzYlkfY0BgF2g1LOv72LJaJ4DvGbhSO/5aE5j7JL3R0SJHQP82cHHd0aQ94HIHGHrSRF20JR9Nb7EIvJ/RN+WBgVugb83prb2P0wcgS10t3wAHh8B4ibLXXd7d293bv2fa/f0A3R1y0YQLRlIAAA12aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjlkM2E5NjQ3LTVmODItNGM1OC05ZTcxLTlhZjczNDNhYTU0MCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkZDUxN2Q1My1iMjZiLTQ1YmQtYmJmMS0wZGFlZjk5ZWZlYzEiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxYjYyYzQwYS01ZTc0LTRkODctOTRiMy0zODU3ZjgyNzFiNmEiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTcxMzc5MzkyNjM3NTQyMyIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjM2IgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCIKICAgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyNDowNDoyMlQyMTo1MjowMyswODowMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjQ6MDQ6MjJUMjE6NTI6MDMrMDg6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowYmQ1M2I0Ny1hMmY2LTRkZTgtOTk0ZS00NzE0YzQzMmQyOTYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjQtMDQtMjJUMjE6NTI6MDYiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+NQsvVgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAAd0SU1FB+gEFg00BuygWF0AAADnSURBVDjLrVSxEYMwEJNyTJLMwCyUzEbJENBBkxZKGIEVlMLGsY3xES664zjzj/5flg38CczEdDEPAPA4I5GEqRt80tSThSyRJGnqBvNTK8Uxn6w4GeWIJ4DWpJD0uw1mlySQBN6Wr/zK0mxCvdjFat8VA46kRs0LkARJaDZd2rWdiCRd65cQ5RapnHoBam80N24GSSKUhNkU125IVvGCj9ZwOfdj+KGi0++cKKp0IFkPrnW2KeLALjrJUNg1UyA6Q9rbze7gUZ+0j+Z+NK5NCIoqcDT9RvzRSFK56vGxwC/Xw91r5TY+4Rh8Eh2MH38AAAAASUVORK5CYII=',
                    karel_img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMwCPz3FB2BV4gZx3lU6gYdv9iQKImK5DPcWWeg7N/Pu7x6EEqRaa5qquAhJkbNkwoRbSCCDIzCUsM7X06BnGK/Ocqq+f7g8TSIq3k2XYzqmsJyF0zSvz6M8iPuHZEnWxpZGjGFgGnQYixQq/N1hGWHe9Q4pYOuMAbBdH/WMvv2tsn/YaKdkcGRWaMB7kcKN0/EkfxRp9BzYR28ZSe+kH97OqL8AFY2We82Nzg0AAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AcxV8/pCItDhYREclQndpFRRxLFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi7OCk6CIl/i8ptIjx4Lgf7+497t4B3laNKYY/DiiqqWeSCSFfWBUCr/BjGCFEMS4yQ0tlF3NwHV/38PD1Lsaz3M/9OUJy0WCARyCOM003iTeIZzdNjfM+cZhVRJn4nDiq0wWJH7kuOfzGuWyzl2eG9VxmnjhMLJR7WOphVtEV4hniiKyolO/NOyxz3uKs1Bqsc0/+wmBRXclyneYYklhCCmkIkNBAFTWYiNGqkmIgQ/sJF/+o7U+TSyJXFYwcC6hDgWj7wf/gd7dGaXrKSQomgL4Xy/qYAAK7QLtpWd/HltU+AXzPwJXa9ddbwNwn6c2uFjkCBreBi+uuJu0BlzvAyJMm6qIt+Wh6SyXg/Yy+qQAM3QIDa05vnX2cPgA56mr5Bjg4BCbLlL3u8u7+3t7+PdPp7wfYGXLPnSDscQAADXZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDQuNC4wLUV4aXYyIj4KIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgIHhtbG5zOkdJTVA9Imh0dHA6Ly93d3cuZ2ltcC5vcmcveG1wLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICB4bXBNTTpEb2N1bWVudElEPSJnaW1wOmRvY2lkOmdpbXA6NzEwNDY2ODQtZDA4ZC00Zjc1LWE2MWItOGYwYmUzNjY4ZjVkIgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmZhYWY4NDdiLTBiYzMtNGFlMi1iODQ4LTExMzZjZGZlNzU3MyIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmY2OTI2OGU1LTliNTItNDE0Mi1hYTc4LTljOWE2ZTZhZTFjMyIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIEdJTVA6QVBJPSIyLjAiCiAgIEdJTVA6UGxhdGZvcm09IldpbmRvd3MiCiAgIEdJTVA6VGltZVN0YW1wPSIxNzEzNzkzNTcxNTA3NzE4IgogICBHSU1QOlZlcnNpb249IjIuMTAuMzYiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIgogICB4bXA6TWV0YWRhdGFEYXRlPSIyMDI0OjA0OjIyVDIxOjQ2OjA5KzA4OjAwIgogICB4bXA6TW9kaWZ5RGF0ZT0iMjAyNDowNDoyMlQyMTo0NjowOSswODowMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmI4YjA4NWNiLTY4MjItNGJmNi05ZGVlLWFhZTJiNTA5NTYzZiIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNC0wNC0yMlQyMTo0NjoxMSIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz65E2CAAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH6AQWDS4LIjzeOwAAAVdJREFUSMflVSGWxCAMTfpG5AgrRyIrK1eu5CiVlZXIOQpyjlBZWTlyjhDHihYGKPAYdtUu7/EIgfY3P/kpwH8cpvXBSwNACQyrnSWwTQ5ucx2G4JCmW/K9XTPALAHGz30eg1nDTyIxAAAW5DrL3StE8jKRDN5dE4nhVQGvCoRezhSRTNpNdD1mDazGpuqqBhF6eW3uz33dtiAP1j5W05L4VBUBbFvyjg+EmfrHVF7g/gSabi/avj6icEWyADoPAL0ZCw6pn86fe9BG/QTUT3tUx4wrzLzRRgyr0RxnbvKqDK8q9ge0GA8xZwfArMYzVZaiPWIsgfgRYE7xQaVVCLz01dmW4pd1BIwlnWCKy1zPspGwGgM7l98uigrjpPqXbc9i1iD0Ao9lcUDWTgFhbXOMhUYkA7X7+7h8LzXNMRYakQTn/83e5YSW8DnQhAhr6Gr5ryP82fENnW6vnRrfvVkAAAAASUVORK5CYII=',
                    font: small_font,
                    empty: new Image(),
                    beeper: new Image(),
                    karel: new Image(),
                    imgw: 25,
                    imgh: 25,
                    bg: '#FFF'
                }
            }

            const start_state = {
                dims: [7, 4],
                field: [
                    "0000000",
                    "0000000",
                    "0000000",
                    "0000000"
                ],
                karel: {
                    col: 0,
                    row: 0,
                    dir: constants.right
                }
            }
            
            // challenges
            const challenges = {
                "none" : [
                    {
                        dims: [6, 3],
                        field0: [
                            "000000",
                            "000000",
                            "000000"
                        ],
                        field1: [
                            "000000",
                            "000000",
                            "000000"
                        ],
                        karel0: {
                            col: 0,
                            row: 0,
                            dir: constants.right
                        },
                        karel1: {
                            col: 0,
                            row: 0,
                            dir: constants.right
                        }
                    }
                ],
                "hospital" : [
                    {
                        dims: [15, 7],
                        field0: [
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000010001000010"
                        ],
                        field1: [
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000011001100011",
                            "000011001100011",
                            "000011001100011"
                        ],
                        karel0: {
                            col: 0,
                            row: 0,
                            dir: constants.right
                        },
                        karel1: {
                            col: 14,
                            row: 0,
                            dir: constants.right
                        }
                    }
                ],
                "spread" : [
                    {
                        dims: [15, 7],
                        field0: [
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "070000000000000"
                        ],
                        field1: [
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "000000000000000",
                            "011111110000000"
                        ],
                        karel0: {
                            col: 0,
                            row: 0,
                            dir: constants.right
                        },
                        karel1: {
                            col: 0,
                            row: 0,
                            dir: constants.right
                        }
                    }
                ],
                "midpoint" : [
                    {
                        dims: [6, 6],
                        field0: [
                            "000000",
                            "000000",
                            "000000",
                            "000000",
                            "000000",
                            "000000"
                        ],
                        field1: [
                            "000000",
                            "000000",
                            "000000",
                            "000000",
                            "000000",
                            "001000"
                        ],
                        karel0: {
                            col: 0,
                            row: 0,
                            dir: constants.right
                        },
                        karel1: {
                            col: 2,
                            row: 0,
                            dir: constants.right
                        }
                    }
                ],
                "sorter" : [
                    {
                        dims: [6, 4],
                        field0: [
                            "000000",
                            "000000",
                            "000000",
                            "024010"
                        ],
                        field1: [
                            "000000",
                            "000000",
                            "000000",
                            "000124"
                        ],
                        karel0: {
                            col: 0,
                            row: 0,
                            dir: constants.right
                        },
                        karel1: {
                            col: 2,
                            row: 0,
                            dir: constants.right
                        }
                    }
                ]
            }

            let settings = {
                auto_indent: true,
                mouse_action: "toggle"
            }

            function setup_field(karel, grid) {
                return {
                    karel: karel,
                    grid: grid,
                    duplicate: () => setup_field(JSON.parse(JSON.stringify(karel)), JSON.parse(JSON.stringify(grid))),
                    matches: other_field => {
                        //return other_field.karel == karel && JSON.stringify(other_field.grid.grid_data) == JSON.stringify(grid.grid_data)
                        return other_field.karel.col == karel.col && other_field.karel.row == karel.row && other_field.karel.dir == karel.dir &&
                             other_field.grid.cols == grid.cols && other_field.grid.rows == grid.rows &&
                             JSON.stringify(other_field.grid.grid_data) == JSON.stringify(grid.grid_data)
                    }
                }
            }

            function blank_field() {
                return setup_field(
                    {col: 0, row: 0, dir: constants.right},
                    {
                        cols: constants.max_cols, rows: constants.max_rows,
                        grid_data: JSON.parse(JSON.stringify(Array(constants.max_rows).fill(Array(constants.max_cols).fill(0))))
                    }
                )
            }

            // make it bigger to make it easily resizeable
            function generate_field_grid(cols, rows, field_grid_strings) {
                function wrapn(n, max) {
                    if (n < 0) {
                        return max + n
                    }
                    return n
                }
                let data = Array(constants.max_rows)
                for (let row = 0; row < rows; row++) {
                    // invert vertical so that Karel stays on the bottom as the field size changes
                    data[row] = field_grid_strings[rows - row - 1].split("").map(c => c - '0')
                    for (let col = cols; col < constants.max_cols; col++) {
                        data[row].push(0)
                    }
                }
                // let data = Array(rows)
                // for (let row = 0; row < rows; row++) {
                //     // invert vertical so that Karel stays on the bottom as the field size changes
                //     data[row] = field_grid_strings[rows - row - 1].split("").map(c => c - '0')
                // }
                return {
                    cols: cols,
                    rows: rows,
                    grid_data: data
                }
            }

            function load_challenge(challenge_string) {
                let obj = challenges[challenge_string][0] // default first test case
                return {
                    state0: setup_field(
                        obj.karel0,
                        generate_field_grid(obj.dims[0], obj.dims[1], obj.field0)
                    ),
                    state1: setup_field(
                        obj.karel1,
                        generate_field_grid(obj.dims[0], obj.dims[1], obj.field1)
                    )
                }
            }


            // set the default to the first style
            let style = styles[Object.keys(styles)[0]]
            let timeout_ms = 500
            // dimensions of the world
            let cols = 7
            let rows = 4
            var canv, ctx
            function setup_state() {
                function push_code_stack(line) {
                    state.code.stack.push(line)
                    let command = state.code.parsed[line]
                    let indent
                    if(command.type == "fcall") {
                        indent = 1
                        if (command.id == "drop_line_by_two") {
                            console.log("dropper")
                        }
                    }
                    else {
                        indent = state.code.indent_level() + 1
                    }
                    state.code.indent_stack.push(indent)
                }
                function pop_code_stack() {
                    state.code.indent_stack.pop()
                    return state.code.stack.pop()
                }
                function indent_lvl() {
                    if(state.code.indent_stack.length == 0) {
                        return 0
                    }
                    return state.code.indent_stack[state.code.indent_stack.length - 1]
                }
                let state = {
                    challenge: "none",
                    challenge_obj: null,
                    prev_tab: "history",
                    code_styled: false,
                    run_history: [],
                    run_history_pos: 0,
                    backup: null,
                    code: {
                        unparsed: [],
                        parsed: [],
                        errors: [],
                        timer: null,
                        timer_f: null,
                        initial_pos: -1,
                        final_pos: -1,
                        pos: 0,
                        load: load_code,
                        stack: [],
                        indent_stack: [],
                        indent_level: indent_lvl,
                        vars: {},
                        fdefs: {},
                        push_stack: push_code_stack,
                        pop_stack: pop_code_stack
                    },
                    field: blank_field(),
                    controls: {
                        play: run_play,
                        play_back: run_play_back,
                        pause: run_pause,
                        rewind: run_rewind,
                        fast_forward: run_fast_forward,
                        forward: run_forward,
                        back: run_back
                    },
                    initial_field: () => {
                        if (state.challenge == "none") {
                            return blank_field()
                        }
                        else {
                            return JSON.parse(JSON.stringify(state.challenge_obj.state0))
                        }
                    },
                    reset_karel: () => {
                        if (state.challenge == "none") {
                            state.field.karel = blank_field().karel
                        }
                        else {
                            state.field.karel = JSON.parse(JSON.stringify(state.challenge_obj.state0.karel))
                        }
                        refresh()
                    },
                    field0: () => {
                        state.field = state.initial_field()
                        refresh()
                    },
                    field1: () => {
                        if (state.challenge != "none") {
                            state.field = JSON.parse(JSON.stringify(state.challenge_obj.state1))
                            refresh()
                        }
                        else {
                            console.log("ERROR 3214")
                        }

                    },
                    reset_field: () => {
                        state.field = state.initial_field()
                    },
                    field_matches: (field) => {
                        return JSON.stringify(field) == JSON.stringify(state.field)
                    },
                    reset_state: () => {
                        // maybe todo ???
                        if (state.challenge == "none") {
                            state.reset_karel()
                        }
                        else {
                            state.reset_field()
                        }
                        // state.field.grid = JSON.parse(initial_field.grid_string)
                        state.run_history = []
                        state.run_history_pos = 0
                        state.code.timer = null
                        state.code.timer_f = null
                        // state.code.initial_pos = 0, // maybe reset doesn't reload code as well?
                        state.code.pos = state.code.initial_pos
                        state.code.stack = []
                        state.code.indent_stack = []
                        state.code.vars = {}
                    },
                    backup_state: () => {
                        state.backup = JSON.stringify(state.field)
                    },
                    restore_state: () => {
                        state.field = JSON.parse(state.backup)
                        refresh()
                    },
                    backup_restore: () => {
                        let backup = JSON.stringify(state.field)
                        if(state.backup) {
                            state.restore_state()
                        }
                        state.backup = backup
                    },
                    render_history: render_history
                }
                function history_string(command) {
                    if(command.type == "call") {
                        return command.id + "()"
                    }
                    else {
                        return "-"
                    }
                }
                function render_history() {
                    let h = state.run_history.map((stuff) => {
                        return stuff.pos + " " + history_string(state.code.parsed[stuff.pos])
                    })
                    return " " + h.slice(0, state.run_history_pos).join("\n ") +
                         "\n>" + h.slice(state.run_history_pos).join("\n ")
                }
                function run_forward() {
                    // not sure if this can happen.
                    if(state.code.parsed.length == 0) {
                        error("SOMEHOW RUNNING BEFORE CODE PROPERLY PARSED")
                        return true
                    }

                    if(state.code.pos == state.code.final_pos) {
                        // todo: maybe fix this
                        if (state.challenge !== "none") {
                            let obj = challenges[state.challenge]
                            let res = state.challenge_obj.state1.matches(state.field)
                            if (res) {
                                popup("Congratulations, Solved")
                            }
                            else {
                                popup("Not correct")

                            }
                        }
                        return true
                    }
                    
                    // there is always a noop code at the end
                    if(state.code.pos >= state.code.parsed.length - 1) {
                        state.code.pos = state.code.parsed.length - 1
                        run_pause()
                        return true
                    }

                    let history_object = {
                        pos: state.code.pos,
                        stack: JSON.stringify(state.code.stack),
                        indent_stack: JSON.stringify(state.code.indent_stack),
                        vars: JSON.stringify(state.code.vars)
                    }

                    let command = state.code.parsed[state.code.pos]

                    if(command.type == "call") {
                        let err = try_call(command.id)
                        if(err) {
                            return true
                        }
                        else {
                            state.code.pos++
                        }
                        
                    }
                    else if(command.type == "fcall") {
                        // TODO maybe? put jumps in code, rather than having a name lookup
                        let pos =  state.code.fdefs[command.id] + 1 // the next line
                        if(pos != undefined) {
                            state.code.push_stack(state.code.pos) // push call position
                            state.code.pos = pos
                        }
                        else {
                            error("CALLING NO FUNCTION")
                            return true
                        }
                    }
                    else if(command.type == "fdef") {
                        // skip function
                        state.code.pos = state.code.parsed[state.code.pos].end
                    }
                    else if(command.type == "for") {
                        if(!state.code.vars.hasOwnProperty(command.var)) {
                            state.code.vars[command.var] = command.count
                        }
                        state.code.vars[command.var]--
                        if(state.code.vars[command.var] < 0) {
                            delete state.code.vars[command.var]
                            state.code.pos = command.end
                        }
                        else {
                            state.code.push_stack(state.code.pos)
                            state.code.pos++
                        }
                    }
                    else if(command.type == "if" || command.type == "while") {
                        let res = try_test(command.test)
                        if(res) {
                            state.code.push_stack(state.code.pos)
                            state.code.pos++
                        }
                        else {
                            state.code.pos = command.end
                        }
                    }
                    else if(command.type == "else") {
                        // this code runs when the if test fails
                        state.code.push_stack(state.code.pos)
                        state.code.pos++
                    }
                    else {
                        // skip over both errors and empty lines
                        state.code.pos++
                    }
                    // whiles jump back to check
                    let next_command = state.code.parsed[state.code.pos]
                    while(state.code.indent_level() > next_command.indent) {
                        let last_line = state.code.stack[state.code.stack.length - 1]
                        let last_command = state.code.parsed[last_line]
                        state.code.pop_stack()
                        if(last_command.type == "fcall") {
                            // TODO: this is a bug, should check again if it's at the end of a while, for example
                            state.code.pos = last_line + 1
                        }
                        else if(last_command.type == "while" || last_command.type == "for") {
                            state.code.pos = last_line
                        }
                        else if(last_command.type == "if") {
                            if(next_command.type == "else") {
                                state.code.pos = next_command.end
                            }
                        }
                        next_command = state.code.parsed[state.code.pos]
                    }
                    style_code(state.code.pos)
                    refresh()
                    // TODO: this might push errored stuff into the history
                    // that doesn't actually execute, not sure if htat's good or bad
                    state.run_history.splice(state.run_history_pos) // maybe not necessary, was for playground
                    state.run_history.push(history_object)
                    state.run_history_pos++
                    return false
                }
                function run_back() {
                    if(state.run_history_pos == 0) {
                        run_pause()
                        return
                    }
                    let stuff = state.run_history[--state.run_history_pos]
                    let command = state.code.parsed[stuff.pos]
                    if(command.type == "call") {
                        try_undo(command.id)
                    }
                    state.code.pos = stuff.pos
                    state.code.stack = JSON.parse(stuff.stack)
                    state.code.indent_stack = JSON.parse(stuff.indent_stack)
                    state.code.vars = JSON.parse(stuff.vars)
                    refresh()
                }
                function run_rewind() {
                    while(state.run_history_pos > 0) {
                        run_back()
                    }
                    refresh()
                }
                function run_fast_forward() {
                    for(let limit = 100000; limit > 0; limit--) {
                        if(run_forward()) {
                            // either an error, or normal completion?
                            refresh()
                            return
                        }
                    }
                    error("Too many steps, you might have an infinite loop")
                    refresh()
                }
                function run_play() {
                    state.timer_f = run_forward
                    state.timer = setInterval(run_forward, timeout_ms)
                    document.getElementById("pause_button").disabled = false
                    style_code(state.code.pos)
                }
                function run_play_back() {
                    state.timer_f = run_back
                    state.timer = setInterval(run_back, timeout_ms)
                    document.getElementById("pause_button").disabled = false
                }
                function run_pause() {
                    if(state.timer_f) {
                        state.timer_f = null
                        clearInterval(state.timer)
                        document.getElementById("pause_button").disabled = true
                    }
                }
                function parse() {

                    
                    function find_test(str) {
                        let split = str.split(":")
                        if (split.length > 1) {
                            let check = split[0].trim()
                            if (check.endsWith("()")) {
                                let func = check.substring(0, check.length - 2)
                                if (constants.conditions[func]) {
                                    return func
                                }
                            }
                            else if (check == "True" || check == "False") {
                                return check
                            }
                        }
                    }
                    
                    function is_space(c) {
                        return c == " " || c == "\t"
                    }
                    // changed from jumps to stack implementation
                    let spaces = state.code.unparsed.map((line) => {
                        // does a kind  of tabs to spaces conversion to calculate indent
                        let sps = 0
                        while (sps < line.length && is_space(line[sps])) {
                            if (line[sps] == "\t") {
                                let extra = constants.tab_size - (sps % constants.tab_size)
                                sps += extra
                            }
                            else {
                                sps++
                            }
                        }
                        return sps
                    })
                    let indents = []
                    let indent_stack = [0]
                    // todo: make sure code is indented back to margin if it isn't already
                    // maybe do this after code is edited  in field by user
                    for(let i = 0; i < spaces.length; i++) {
                        if(spaces[i] > indent_stack[indent_stack.length - 1]) {
                            indent_stack.push(spaces[i])
                        }
                        else if(indent_stack.length > 1) {
                            while(spaces[i] <= indent_stack[indent_stack.length - 2]) {
                                indent_stack.pop()
                            }
                        }
                        indents[i] = indent_stack.length - 1
                    }
                    function find_block_end(start) {
                        let res
                        for(res = start + 1; res < spaces.length && (spaces[res] > spaces[start] || state.code.unparsed[res].trim == ""); res++);
                        res--
                        while(res > 0 && state.code.unparsed[res].trim() == "") {
                            res--
                        }
                        return res + 1
                    }
                    state.code.parsed = []
                    state.code.errors = []
                    state.code.fdefs = {}
                    for(let i = 0; i < state.code.unparsed.length; i++) {
                        let line = state.code.unparsed[i].trim()
                        let index = line.length - 2
                        
                        if(line == "" || line.startsWith("#")) {
                            res = {type: "noop"}
                        }
                        else if(line.substring(index) == "()" && constants.functions[line.substring(0, index)]) {
                            if(constants.functions[line.substring(0, index)]) {
                                res = {type: "call", id: line.substring(0, index)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line.startsWith("if ")) {
                            let test = find_test(line.substring(3))
                            if(test) {
                                res = {type: "if", test: test, end: find_block_end(i)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line.startsWith("else")) {
                            res = {type: "else", end: find_block_end(i)}
                        }
                        else if(line.startsWith("for ")) {
                            let words = line.split(" ")
                            if(words.length == 4 && words[3].length >= 9) {
                                let num_string = (words[3]).substring(6, words[3].length - 2)
                                let count = parseInt(num_string)
                                res = {type: "for", var: words[1], count: count, end: find_block_end(i)}
                            }
                            else {
                                res = {type: "error"}
                            }
                            console.log("forrr")
                        }
                        else if(line.startsWith("while ")) {
                            let test = find_test(line.substring(6))
                            if(test) {
                                res = {type: "while", test: test, end: find_block_end(i)}
                            }
                            else {
                                res = {type: "error"}
                            }
                        }
                        else if(line.startsWith("def ")) {
                            let id = line.substring(4, line.length - 3)
                            res = {type: "fdef", id: id, end: find_block_end(i)}
                            state.code.fdefs[id] = i
                        }
                        else if(line.endsWith("()")) {
                            let id = line.substring(0, line.length - 2)
                            res = {type: "fcall", id: id}
                        }
                        else {
                            res = {type: "error"}
                        }
                        res["indent"] = indents[i]
                        state.code.parsed.push(res)
                        if (res.type == "error") {
                            state.code.errors.push([i, line])
                        }
                    }

                    // todo: find errors, like no indented code after a colon
                    // and calling functions that don't exist

                    // indent check
                    let parsed = state.code.parsed
                    for (let i = 0; i < parsed.length; i++) {
                        if (parsed[i].type == "while" || parsed[i].type == "for" || parsed[i].type == "if" || parsed[i].type == "fdef") {
                            let error = true
                            let j
                            for (j = i + 1; j < parsed.length && parsed[j].type == "noop"; j++) {
                            }

                            if (j == parsed.length) {
                                state.code.errors.push([i, "no code after " + parsed[i].type])
                            }
                            else if (parsed[i].indent >= parsed[j].indent) {
                                state.code.errors.push([i, "no indent after " + parsed[i].type])
                            }
                        }
                    }
                }
                function load_code(code) {
                    state.code.unparsed = code.split("\n")
                    parse()
                    state.code.initial_pos = -1
                    // find first line
                    for(let i = 0; i < state.code.parsed.length; i++) {
                        let line = state.code.parsed[i]
                        if(line.indent == 0 && line.type != "fdef" && line.type != "noop" && line.type != "error") {
                            state.code.initial_pos = i
                            break
                        }
                    }
                    state.code.final_pos = state.code.parsed.length - 1
                    if(state.code.initial_pos == -1) {
                        let i = state.code.fdefs["main"]
                        if(i != undefined) {
                            state.code.initial_pos =  i
                            state.code.final_pos = state.code.parsed[i].end
                        }
                        else {
                            state.code.initial_pos = 0
                        }
                    }
                    state.code.pos = state.code.initial_pos
                }
                return state
            }
            var state = setup_state()
            function popup(msg, title="") {
                state.timer_f = null
                clearInterval(state.timer)
                if(error_popup_on) {
                    let md = document.getElementById("message_div")
                    md.innerHTML = "<h3>" + title + "</h3>" + msg
                    md.style.display = "block"
                    document.getElementById("popup_div").style.display = "block"
                }
            }
            function error(msg) {
                console.log("ERROR - " + msg)
                popup(msg, "Error")
            }
            function draw(img, col, row, dir = constants.right) {
                if(dir == constants.down) {
                    angle = Math.PI / 2;
                }
                else if(dir == constants.left) {
                    angle = Math.PI;
                }
                else if(dir == constants.up){
                    angle = Math.PI * 3 / 2;
                }
                else {
                    angle = 0;
                }
                ctx.save()
                ctx.translate(style.imgw * (col + .5), style.imgh * (rows - row - .5))
                ctx.rotate(angle)
                ctx.translate(-.5 * img.width, -.5 * img.height)
                ctx.drawImage(img, 0, 0)
                ctx.restore()
            }
            function draw_count(font, col, row, count) {
                draw(font.img_border, col, row)
                let digits = count.toString().split("").map((d) => parseInt(d))
                
                ctx.fillStyle = font.bg

                let w = digits.length * font.width
                let x0 = (col + .5) * style.imgw - w / 2
                let y0 = (rows - row - .5) * style.imgh - font.height / 2
                // const border = 1
                // let digit = 2
                // ctx.fillRect(x0 - border, y0 - border, w + 2 * border, font.height + 2 * border)
                for(let i = 0; i < digits.length; i++) {
                    ctx.drawImage(font.img_numbers, digits[i] * font.width, 0, font.width, font.height,
                        x0 + i * font.width, y0, font.width, font.height)
                }
                // ctx.drawImage(style.beeper, 0, 0, style.imgw, style.imgh,
                //     col * style.imgw, row * style.imgh, style.imgw, style.imgh)
                
                ctx.fillStyle = style.bg
            }
            function draw_grid() {
                for(let row = 0; row < rows; row++) {
                    for(let col = 0; col < cols; col++) {
                        if(state.field.grid.grid_data[row][col] == 0) {
                            draw(style.empty, col, row)
                        }
                    }
                }
            }
            function draw_beepers() {
                for(let row = 0; row < rows; row++) {
                    for(let col = 0; col < cols; col++) {
                        if(state.field.grid.grid_data[row][col] > 0) {
                            draw(style.beeper, col, row)
                        }
                    }
                }
            }
            function draw_karel() {
                draw(style.karel, state.field.karel.col, state.field.karel.row, state.field.karel.dir)
            }
            function draw_numbers() {
                for(let row = 0; row < rows; row++) {
                    for(let col = 0; col < cols; col++) {
                        let n = state.field.grid.grid_data[row][col]
                        if(n > 1) {
                            draw_count(style.font, col, row, n)
                        }
                    }
                }
            }
            function try_undo(id) {
                let karel = state.field.karel
                let grid = state.field.grid.grid_data
                // might add error check later
                if(id == "move") {
                    if(karel.dir == constants.right) {
                        karel.col -= 1
                    }
                    else if(karel.dir == constants.down) {
                        karel.row += 1
                    }
                    else if(karel.dir == constants.left) {
                        karel.col += 1
                    }
                    else if(karel.dir == constants.up) {
                        karel.row -= 1
                    }
                    else {
                        error_msg("issue 850")
                    }
                }
                else if(id == "turn_left") {
                    karel.dir = (karel.dir + 1) % 4
                }
                else if(id == "put_beeper") {
                    if(grid[karel.row][karel.col] == 0) {
                        error("NO BEEPERS TO UNDO PUT")
                        return true
                    }
                    grid[karel.row][karel.col]--
                }
                else if(id == "pick_beeper") {
                    grid[karel.row][karel.col]++
                }
            }
            function front_is_clear() {
                let karel = state.field.karel
                if(karel.dir == constants.right && karel.col >= cols - 1) {
                    return false
                }
                else if(karel.dir == constants.down && karel.row <= 0) {
                    return false
                }
                else if(karel.dir == constants.left && karel.col <= 0) {
                    return false
                }
                else if(karel.dir == constants.up && karel.row >= rows - 1) {
                    return false
                }
                return true

            }
            function try_call(id) {
                let karel = state.field.karel
                let grid = state.field.grid.grid_data
                if(id == "move") {
                    if(!front_is_clear()) {
                        error("FRONT IS NOT CLEAR")
                        return true
                    }
                    if(karel.dir == constants.right) {
                        karel.col += 1
                    }
                    else if(karel.dir == constants.down) {
                        karel.row -= 1
                    }
                    else if(karel.dir == constants.left) {
                        karel.col -= 1
                    }
                    else if(karel.dir == constants.up) {
                        karel.row += 1
                    }
                    else {
                        error_msg("issue 905")
                    }
                    
                }
                else if(id == "turn_left") {
                    karel.dir = (karel.dir + 3) % 4
                }
                else if(id == "put_beeper") {
                    grid[karel.row][karel.col]++
                }
                else if(id == "pick_beeper") {
                    if(grid[karel.row][karel.col] == 0) {
                        error("NO BEEPERS TO PICK")
                        return true
                    }
                    grid[karel.row][karel.col]--
                }
            }
            function try_test(test) {
                let karel = state.field.karel
                let grid = state.field.grid.grid_data
                if(test == "True") {
                    return true
                }
                else if(test == "False") {
                    return false
                }
                else if(test == "front_is_clear") {
                    return front_is_clear()
                }
                else if(test == "front_is_blocked") {
                    return !front_is_clear()
                }
                else if(test == "beepers_present") {
                    return grid[karel.row][karel.col] > 0
                }
                else if(test == "no_beepers_present") {
                    return grid[karel.row][karel.col] == 0
                }
                else if(test == "front_is_blocked") {
                    return !front_is_clear()
                }
                else if(test == "left_is_clear") {
                    karel.dir--
                    res = front_is_clear()
                    karel.dir++
                    return res
                }
                else if(test == "left_is_blocked") {
                    karel.dir--
                    res = !front_is_clear()
                    karel.dir++
                    return res
                }
                else if(test == "right_is_clear") {
                    karel.dir++
                    res = front_is_clear()
                    karel.dir--
                    return res
                }
                else if(test == "right_is_blocked") {
                    karel.dir++
                    res = !front_is_clear()
                    karel.dir--
                    return res
                }
                else if(test == "facing_north") {
                    return karel.dir == constants.up
                }
                else if(test == "not_facing_north") {
                    return karel.dir !== constants.up
                }
                else if(test == "facing_south") {
                    return karel.dir == constants.down
                }
                else if(test == "not_facing_south") {
                    return karel.dir !== constants.down
                }
                else if(test == "facing_east") {
                    return karel.dir == constants.right
                }
                else if(test == "not_facing_east") {
                    return karel.dir !== constants.right
                }
                else if(test == "facing_west") {
                    return karel.dir == constants.left
                }
                else if(test == "not_facing_west") {
                    return karel.dir !== constants.left
                }
// //beepers_in_bag()	no_beepers_in_bag()	Does Karel have any beepers in its bag?
            }
            // add to code and run
            function execute_call(id) {
                let err = try_call(id)
                if(!err) {
                    refresh()
                }
            }
            function click_box(col, row) {
                let grid = state.field.grid.grid_data
                let karel = state.field.karel
                if (settings.mouse_action == "kmove") {
                    karel.col = col
                    karel.row = row
                }
                else if (settings.mouse_action == "add") {
                    grid[row][col] += 1
                }
                else if (settings.mouse_action == "toggle" && grid[row][col] > 0) {
                    grid[row][col] -= 1
                }
                else if(grid[row][col] > 0) {
                    grid[row][col] = 0
                }
                else {
                    grid[row][col] = 1
                }
                refresh()
            }
            function hotkey(str) {
                if(str == "w") {
                    execute_call("pick_beeper")
                }
                if(str == "s") {
                    execute_call("put_beeper")
                }
                if(str == "d") {
                    execute_call("move")
                }
                if(str == "a") {
                    execute_call("turn_left")
                }
                if(str == "u") {
                    undo()
                }
                if(str == "r") {
                    redo()
                }
            }
            function refresh() {
                let ta = document.getElementById("ta1")
                let tab = document.getElementById("id_title").value
                if(tab == "history") {
                    ta.value = state.render_history()
                }
                else if(tab == "code" && state.code_styled) {
                    style_code(state.code.pos)
                }
                ctx.fillRect(0, 0, canv.width, canv.height)
                draw_grid()
                draw_karel()
                draw_beepers()
                draw_numbers()
            }
            function load_all_images() {
                var counter = 0
                function waiter() {
                    counter--
                    if(counter == 0) {
                        refresh()
                    }
                }
                Object.keys(styles).forEach((id) => {
                    counter += 3
                    if(styles[id].font.img_border == null) {
                        styles[id].font.img_border = new Image()
                        styles[id].font.img_border.src = styles[id].font.base64_border
                        styles[id].font.img_numbers = new Image()
                        styles[id].font.img_numbers.src = styles[id].font.base64_numbers
                    }
                    styles[id].empty.src = styles[id].empty_img
                    styles[id].beeper.src = styles[id].beeper_img
                    styles[id].karel.src = styles[id].karel_img
                    styles[id].empty.addEventListener('load', waiter)
                    styles[id].beeper.addEventListener('load', waiter)
                    styles[id].karel.addEventListener('load', waiter)
                })

            }
            function setup() {
                canv = document.getElementById("canv1")
                ctx = canv.getContext("2d")
                
                ctx.imageSmoothingEnabled = false

                canv.addEventListener('mousedown', function(e) {
                    const rect = canv.getBoundingClientRect()
                    const col = cols * (e.clientX - rect.left) / rect.width
                    const row = rows * (rect.bottom - e.clientY) / rect.height

                    
                    if (settings.mouse_action == "kturn") {
                        let karel = state.field.karel
                        let dx = col - karel.col - .5
                        let dy = row - karel.row - .5
                        if (Math.abs(dx) > Math.abs(dy)) {
                            if (dx > 0) {
                                karel.dir = constants.right
                            }
                            else {
                                karel.dir = constants.left
                            }
                        }
                        else {
                            // positive y is up
                            if (dy > 0) {
                                karel.dir = constants.up
                            }
                            else {
                                karel.dir = constants.down
                            }
                        }
                        refresh()
                    }
                    else {
                        click_box(Math.floor(col), Math.floor(row))
                    }
                })

                // keypress everywhere but text area
                onkeypress = function(e) {
                    e = e || window.event
                    var charCode = (typeof e.which == "number") ? e.which : e.keyCode
                    
                    if (charCode > 0) {
                        hotkey(String.fromCharCode(charCode))
                    }
                }

                function insertAtCursor(myField, myValue) {
                    if (myField.selectionStart || myField.selectionStart == '0') {
                        var startPos = myField.selectionStart;
                        var endPos = myField.selectionEnd;
                        myField.value = myField.value.substring(0, startPos)
                            + myValue
                            + myField.value.substring(endPos, myField.value.length);
                    }
                    else {
                        myField.value += myValue;
                    }
                }

                
                function tab_out(ta) {
                    //MOZILLA and others
                    if (ta.selectionStart || ta.selectionStart == '0') {
                        let pre0 = ta.value.slice(0, ta.selectionStart)
                        let post = ta.value.slice(ta.selectionEnd)
                        let mid0 = ta.value.slice(ta.selectionStart, ta.selectionEnd)
                        if (pre0.indexOf("\n") < 0) {
                            pre1 = "\t" + pre0
                        }
                        else {
                            pre1 = pre0.split("\n").slice(0, -1).join("\n") + "\n\t" + pre0.split("\n").slice(-1)[0]
                        }
                        if (mid0 == "") {
                            pre1 = pre0
                            mid1 = "\t"
                            ta.value = pre1 + mid1 + post
                            ta.setSelectionRange(pre1.length + mid1.length , pre1.length + mid1.length)
                        }
                        // else if (mid0.indexOf("\n") < 0) {
                        //     mid1 = "\t"
                        //     ta.value = pre1 + mid1 + post
                        //     ta.setSelectionRange(pre1.length + mid1.length , pre1.length + mid1.length)
                        // }
                        else {
                            mid1 = mid0.split("\n").join("\n\t")
                            ta.value = pre1 + mid1 + post
                            ta.setSelectionRange(pre1.length, pre1.length + mid1.length)
                        }
                        // if (mid0 == "") {
                        //     pre1 = pre0
                        //     mid1 = "\t"
                        //     ta.value = pre1 + mid1 + post
                        //     ta.setSelectionRange(pre1.length + mid1.length , pre1.length + mid1.length)
                        // }
                        // else {
                        //     pre1 = pre0.split("\n").slice(0, -1).join("\n") + "\n\t" + pre0.split("\n").slice(-1)[0]
                        //     mid1 = mid0.split("\n").join("\n\t")
                        //     ta.value = pre1 + mid1 + post
                        //     ta.setSelectionRange(pre1.length, pre1.length + mid1.length)
                        // }
                    } else {
                        ta.value += "\t"
                    }
                }

                function tab_in(ta) {
                    function tab_remover(str) {
                        if (str.startsWith("\t")) {
                            return str.slice(1)
                        }
                        return str
                    }
                    let pre = ta.value.substring(0, ta.selectionStart).split("\n")                 
                    let mid = ta.value.substring(ta.selectionStart, ta.selectionEnd).split("\n")
                    if (pre.length == 1) {
                        pre1 = tab_remover(pre[0])
                    }  
                    else {
                        pre1 = pre.slice(0, -1).join("\n") + "\n" + tab_remover(pre.slice(-1)[0])  
                    }  
                    if (mid.length == 1) {
                        mid1 = mid[0]
                    }
                    else {
                        mid1 = mid[0] +"\n" + mid.slice(1).map(tab_remover).join("\n")
                    }
                    ta.value = pre1 + mid1 + ta.value.substring(ta.selectionEnd)
                    ta.setSelectionRange(pre1.length, pre1.length + mid1.length)
                }

                let ta1 = document.getElementById("ta1")
                ta1.style.tabSize = "" + constants.tab_size
                ta1.onkeydown = function(e) {
                    if (e.key == "Tab") {
                        e.preventDefault()
                        if (e.shiftKey) {
                            tab_in(ta1)
                        }
                        else {
                            tab_out(ta1)
                        }
                    }
                    else if(e.key == "Enter") {
                        if (settings.auto_indent && ta1.selectionStart == ta1.selectionEnd) {
                            let pos = ta1.selectionStart
                            const spaceRegex = /\n([\ \t]*)[^\n]+$/
                            let matches = spaceRegex.exec(ta1.value.slice(0, pos))
                            if (matches.length > 1) {
                                e.preventDefault()
                                let ws = matches[1]
                                ta1.value = ta1.value.slice(0, pos) + "\n" + ws + ta1.value.slice(pos)
                                ta1.setSelectionRange(pos + ws.length + 1, pos + ws.length + 1)
                            }
                        }
                    }

                }
                ta1.onkeypress = function(e) {
                    console.log(e)
                    e.stopPropagation()
                }


                let ss = document.getElementById("style_switcher")
                ss.innerHTML = Object.keys(styles).map((id) => '<option value="' + id + '">' + id + '</option>').join("\n")

                load_all_images()
                change_tab()
                change_fps()
                change_style()
                
                ta1.value = "# calls main\nmain()\n\ndef main():\n\tmove()"
                change_code()

                // there has to be a better way
                window.addEventListener('mousemove', resize_canvas)
            }

            function update_ui_to_field() {
                document.getElementById("col_field").value = "" + cols
                document.getElementById("row_field").value = "" + rows
                if (state.challenge == "none") {
                    document.getElementById("col_field").disabled = false
                    document.getElementById("row_field").disabled = false
                }
                else {
                    document.getElementById("col_field").disabled = true
                    document.getElementById("row_field").disabled = true
                }
            }

            // function load_field_state(dims, field, karel) {
            //     cols = dims[0]
            //     rows = dims[1]
            //     data = JSON.parse(JSON.stringify(Array(constants.max_rows).fill(Array(constants.max_cols).fill(0))))
            //     for (let row = 0; row < rows; row++) {
            //         for (let col = 0; col < cols; col++) {
            //             data[row][col] = state.field.grid.grid_data[row][col]
            //         }
            //     }
            //     state.field.grid = {
            //         cols: constants.max_cols,
            //         rows: constants.max_rows,
            //         grid_data: data
            //     }
            //     update_ui_to_field()
            // }

            // function resize_grid(dims) {

            // }

            function set_challenge() {
                let challenge = document.getElementById("challenge_switcher").value
                state.challenge = challenge
                if (challenge == "none") {
                    //load_state(start_state.dims, start_state.field, start_state.karel)
                    // juste enable column/row setting ui fields
                    update_ui_to_field()

                    // just copy current field
                }
                else {
                    state.challenge_obj = load_challenge(challenge)
                    state.reset_field()
                    let test = challenges[challenge][0]

                    // maybe cols and rows is if the grid displayed is different from the grid data?
                    // otherwise not in state variable?
                    cols = test.dims[0]
                    rows = test.dims[1]
                    
                    state.field0() // = state.initial_field() // challenges[challenge][0])

                    
                    refresh() // I guess refresh the field... or something?
                    // taken from setting col function
                    change_style() // to refresh things?
                }
                update_ui_to_field()
            }
            function change_tab() {
                let old_state
                let tab = document.getElementById("id_title").value
                let ta = document.getElementById("ta1")
                // backup
                if(state.prev_tab == "code") {
                    if(!state.code_styled) {
                        state.code.unparsed = ta.value.split("\n")
                    }
                }
                
                if(state.prev_tab == "playground" && (tab == "code" || tab == "history") ||
                    tab == "playground" && (state.prev_tab == "code" || state.prev_tab == "history")) {
                    state.backup_restore()
                }
                
                if(tab == "code") {
                    ta.disabled = false
                    ta.value = state.code.unparsed.join("\n")
                    ta.style.display = "block"
                }
                else if(tab == "history") {
                    ta.disabled = true
                    ta.value = state.render_history()
                    ta.style.display = "block"
                }
                else if(tab == "playground") {
                    ta.style.display = "none"
                    document.getElementById("td1").width = 0
                }

                if(tab == "playground") {
                    constants.playground_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "inline-block"
                    })
                    constants.code_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "none"
                    })
                }
                else {
                    constants.code_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "inline-block"
                    })
                    constants.playground_buttons.forEach((id) => {
                        document.getElementById(id).style.display = "none"
                    })
                }
                state.prev_tab = tab
                // rewrites text area
                refresh()
            }
            // function style_code(marker = -1) {
            //     let errors = []
            //     let res = []
            //     for(let i = 0; i < state.code.unparsed.length; i++) {
            //         if(i == marker) {
            //             symbol = "> " //
            //         }
            //         else if(state.code.parsed[i].type == "error") {
            //             symbol = "X " //
            //             errors.push([i + 1, state.code.unparsed[i]])
            //         }
            //         else {
            //             symbol = "* " //
            //             // symbol = "* " //
            //         }
            //         res.push(symbol + state.code.unparsed[i])
            //     }
            //     document.getElementById("ta1").value = res.join("\n")
            //     state.code_styled = true

            //     // maybe todo: maybe change a bit
            //     if (errors.length > 0) {
            //         let error_msg = errors.map(x => "Line " + x[0] + ": " + x[1]).join("<br>")
            //         error(error_msg)
            //     }

            // }
            function style_code(marker = -1) {
                let res = []
                for(let i = 0; i < state.code.unparsed.length; i++) {
                    if(i == marker) {
                        symbol = "> " //
                    }
                    else if(state.code.parsed[i].type == "error") {
                        symbol = "X " //
                    }
                    else {
                        symbol = "* " //
                        // symbol = "* " //
                    }
                    res.push(symbol + state.code.unparsed[i])
                }
                document.getElementById("ta1").value = res.join("\n")
                state.code_styled = true

                // maybe todo: maybe change a bit
                if (state.code.errors.length > 0) {
                    let error_msg = state.code.errors.map(x => "Line " + x[0] + ": " + x[1]).join("<br>")
                    error(error_msg)
                }

            }
            function unstyle_code() {
                if(state.code_styled) {
                    let ta = document.getElementById("ta1")
                    ta.value = state.code.unparsed.join("\n")
                    state.code_styled = false
                }
            }
            function edit_code() {
                unstyle_code()
            }
            function change_code() {
                let tab = document.getElementById("id_title").value
                let ta = document.getElementById("ta1")
                if(tab == "code") {
                    // state.reset()

                    // CODE "CLEANING"
                    let lines = ta.value.split("\n")
                    // set indentation of blank lines to be the same as last line
                    for(let i = 1; i < lines.length; i++) {
                        if(lines[i].trim() == "") {
                            let j
                            for(j = 0; j < lines[i-1].length && lines[i-1].charAt(j) == " "; j++);
                            lines[i] = lines[i-1].substring(0, j)
                        }
                    }
                    // require it end in newline at base indentation level
                    // (one reason is for a required noop when needing to loop back for a while loop)
                    if(lines[lines.length - 1].trim() == "") {
                        lines.length = lines.length - 1
                    }
                    lines.push("")
                    ta.value = lines.join("\n")
                    state.code.load(ta.value)

                    // TODO maybe if it's worth it, allow modifying code while retaining state
                    state.reset_state()
                }
            }
            function resize_canvas() {
                const margins = 10
                const max_h = document.documentElement.clientHeight * .8
                console.log("resizing the canvas")
                const rect = document.getElementById("canvas_holder").getBoundingClientRect()
                let h = Math.min(max_h, rect.width)
                if (rect.width / h > cols / rows) {
                    // height limited
                    canv.style.width = (h * cols / rows - margins) + "px"
                    canv.style.height = (h - margins) + "px"
                }
                else {
                    canv.style.width = (rect.width - margins) + "px"
                    canv.style.height = (rect.width * rows / cols - margins) + "px"
                }

            }
            function change_style() {
                style = styles[document.getElementById("style_switcher").value]
                canv.width = style.imgw * cols
                canv.height = style.imgh * rows
                // canv.style.aspectRatio = cols + "/" + rows
                resize_canvas()

                ctx.fillStyle = style.bg
                refresh()
            }
            function change_fps() {
                timeout_ms = 10000 / document.getElementById("fps_field").value
                if(state.timer_f) {
                    clearInterval(state.timer)
                    state.timer = setInterval(state.timer_f, timeout_ms)
                }
            }
            // cols and rows might not be used much, since they used to be broken
            function change_cols() {
                cols = parseInt(document.getElementById("col_field").value)
                state.reset_state() // might not need this at some point
                change_style() // to refresh things?
            }
            function change_rows() {
                rows = parseInt(document.getElementById("row_field").value)
                // if(state.field.krow >= rows) {
                //     state.field.krow = rows - 1
                // }
                state.reset_state() // might not need this at some point
                change_style() // to refresh things?
            }
            function blurs() {
                let tab = document.getElementById("id_title").value
                if(tab == "code") {
                    style_code()
                }
            }
            function close_popup() {
                document.getElementById("popup_div").style.display = "none"
                document.getElementById("message_div").style.display = "none"
            }
            function warning_toggle() {
                error_popup_on = document.getElementById("warn").checked
            }
            function indent_toggle() {
                settings.auto_indent = document.getElementById("indenter").checked
            }
            function set_mouse_action() {
                settings.mouse_action = document.getElementById("mouse_action").value
            }
            function load_state(str) {
                if (state.challenge == "none") {

                }
                else if (str == "start") {
                    state.field0()
                }
                else if (str == "end") {
                    state.field1()
                }
            }
            
        </script>

        </head>
        
    <body onload="setup()">

    <div id="everything_holder">
        <table id="tab1" style="width:100%;height:100%">
            <tbody><tr>
                <td id="td1" width="16%">
                    <textarea id="ta1" onblur="blurs()" onfocus="edit_code()" onchange="change_code()"></textarea>
                </td>
                <td>
                    <div id="canvas_holder">
                        <canvas id="canv1" width="1080" height="432"></canvas>
                    </div>
                </td>
            </tr>
        </tbody></table>
        
        <select name="id_title" id="id_title" onchange="change_tab()">
            <option value="code">code</option>
            <option value="history">history</option>
            <option value="playground">playground</option>
        </select>
        <button id="move_button" onclick="execute_call(&quot;move&quot;)" style="display: none;">move</button>
        <button id="turn_button" onclick="execute_call(&quot;turn_left&quot;)" style="display: none;">turn_left</button>
        <button id="put_button" onclick="execute_call(&quot;put_beeper&quot;)" style="display: none;">put_beeper</button>
        <button id="pick_button" onclick="execute_call(&quot;pick_beeper&quot;)" style="display: none;">pick_beeper</button>
        <button id="reset_button" onclick="state.restore_state()" style="display: none;">reset state to code</button>
        <button id="rewind_button" onclick="state.controls.pause();state.controls.rewind()" style="display: inline-block;">&lt;&lt;</button>
        <button id="play_back_button" onclick="state.controls.pause();state.controls.play_back()" style="display: inline-block;">&lt;=</button>
        <button id="back_button" onclick="state.controls.pause();state.controls.back()" style="display: inline-block;">&lt;</button>
        <button id="pause_button" onclick="state.controls.pause()" disabled="true" style="display: inline-block;">||</button>
        <button id="forward_button" onclick="state.controls.pause();state.controls.forward()" style="display: inline-block;">&gt;</button>
        <button id="play_button" onclick="state.controls.pause();state.controls.play()" style="display: inline-block;">=&gt;</button>
        <button id="fast_forward_button" onclick="state.controls.pause();state.controls.fast_forward()" style="display: inline-block;">&gt;&gt;</button>
        <select name="style_switcher" id="style_switcher" onchange="change_style()">
            <option value="flower">flower</option>
            <option value="frog">frog</option>
            <option value="monkey">monkey</option>
        </select>
        <label for="fps_field">FPS</label>
        <input type="number" id="fps_field" name="fps_field" onchange="change_fps()" min="1" max="1000" value="30">
        
        <div id="challenger" style="overflow:none">
            <select name="challenge_switcher" id="challenge_switcher" onchange="set_challenge()">
                <option value="none">no challenge</option>
                <option value="hospital">hospital</option>
                <option value="spread">spread</option>
                <option value="midpoint">midpoint</option>
                <option value="sorter">sorter</option>
            </select>
            <label for="row_field">rows</label>
            <input type="number" id="row_field" name="row_field" onchange="change_rows()" min="1" max="100" value="4">
            <label for="col_field">cols</label>
            <input type="number" id="col_field" name="col_field" onchange="change_cols()" min="1" max="100" value="7">
            <button onclick="load_state('start')">start state</button>
            <button onclick="load_state('end')">solution state</button>
            <button id="run_button" onclick="state.controls.pause();state.controls.rewind();load_state('start');state.controls.play()" style="display: inline-block;">Run code</button>

        </div>
        <label for="mouse_action">Click to:</label>
        <select name="mouse_action" id="mouse_action" onchange="set_mouse_action()">
            <option value="toggle">toggle beeper</option>
            <option value="add">add beeper</option>
            <option value="kmove">move karel</option>
            <option value="kturn">turn karel</option>
        </select>
        <input type="checkbox" onchange="warning_toggle()" id="warn" name="warn" checked="">
        <label for="warn">Error popups</label>
        <input type="checkbox" onchange="indent_toggle()" id="indenter" name="indenter" checked="">
        <label for="indenter">Keep indent</label>
        <div id="popup_div" onclick="close_popup()"></div>
        <div id="message_div" onclick="close_popup()">bone</div>
    
    </div>
</body></html>
